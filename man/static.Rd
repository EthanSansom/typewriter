% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/modifiers.R
\name{static}
\alias{static}
\title{Mark a function argument as being persistently typed}
\usage{
static(x)
}
\arguments{
\item{x}{\verb{[call]}

A call to either:
\itemize{
\item A type-checking function
\item Other argument modifiers (e.g. \code{\link[=required]{required()}}, \code{\link[=optional]{optional()}}, \code{\link[=maybe]{maybe()}})
}}
}
\value{
If used outside of a function typing context (e.g. \code{\link{\%<~\%}} or \code{\link[=typed]{typed()}})
this function raises an error. In a function typing context, returns an
expression marked as being a persistently typed argument.
}
\description{
Indicates that a function argument should not be assigned to a new
type within the body of a typed function. When used in a typed function
declaration, this modifier assigns it's argument using \code{\link[=assign_typed]{assign_typed()}}
within the body of the declared function.

As a function author, this is useful to ensure that a given argument's
type is never inadvertently changed within the body of a function (e.g.
an argument is coerced from an integer to a double).

This function may only be used when declaring a function with \code{\link{\%<~\%}}
or \code{\link[=typed]{typed()}}.
}
\details{
When an argument is \code{static()} calls to \code{\link[=assign_typed]{assign_typed()}} and
\code{\link[=rethrow_parent_assignment_error]{rethrow_parent_assignment_error()}} are inserted into the typed function's
body.

\if{html}{\out{<div class="sourceCode r">}}\preformatted{# Typed function declaration
foo <- typed(function(x = static(chk::chk_integer())) \{
  return(x)
\})

# Roughly equivalent to
foo <- function(x) \{
  typewriter::rethrow_parent_assignment_error(
    typewriter::assign_typed(x, chk::chk_integer())
  )
  return(x)
\}
}\if{html}{\out{</div>}}
}
\examples{
\dontshow{if (requireNamespace("chk", quietly = TRUE)) withAutoprint(\{ # examplesIf}
# This function inadvertently coerces `x` to a numeric
# vector, even though `x` began as an integer vector.
replace_na_bad <- typed(function(x = chk::chk_integer()) {
  x[is.na(x)] <- 0
  x
})
replace_na_bad(1L)
class(replace_na_bad(1L))

# We can prevent this accident using `static()`, which
# will check that `x` remains an integer for the duration
# of `replace_na_bad()`.
replace_na_bad <- typed(function(x = static(chk::chk_integer())) {
  x[is.na(x)] <- 0
  x
})
try(replace_na_bad(1L))

# If `x` is never coerced to another type within the function,
# then it proceeds without error.
replace_na_good <- typed(function(x = static(chk::chk_integer())) {
  x[is.na(x)] <- 0L
  x
})
replace_na_good(1L)
replace_na_good(c(5L, NA_integer_))
class(replace_na_good(c(5L, NA_integer_)))
\dontshow{\}) # examplesIf}
}
