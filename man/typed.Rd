% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/typed-function.R
\name{typed}
\alias{typed}
\title{Declare a function with typed arguments}
\usage{
typed(call, env = rlang::caller_env())
}
\arguments{
\item{call}{\verb{[call]}

A call to \code{function}.}

\item{env}{\verb{[environment]}

The environment of the returned function, passed to \code{\link[rlang:new_function]{rlang::new_function()}}.
By default \code{env} is the caller's environment.}
}
\value{
A typed function.
}
\description{
\code{typed()} modifies a function declaration (e.g. \code{function(x) { x + x }}) by
inserting additional calls into the function body to check the types of its
arguments.

To declare the type of an argument in \code{function}, set it's default value to a
type-checking call. For instance, \code{\link[chk:chk_integer]{chk::chk_integer()}} raises an error if its
first argument is not an integer. Using this, we can declare that the argument
\code{x} must be an integer like so:

\if{html}{\out{<div class="sourceCode r">}}\preformatted{integer_doubler <- typed(function(x = chk::chk_integer()) \{
 x + x
\})
}\if{html}{\out{</div>}}

This returns a function which looks like \code{function(x) { x + x }} and which
calls \code{chk::chk_integer(x)} prior to executing its body.

Default argument values are taken from the first argument of the type-checking
call. For instance, the following:

\if{html}{\out{<div class="sourceCode r">}}\preformatted{integer_doubler_2 <- typed(function(x = chk::chk_integer(0L)) \{
 x + x
\})
}\if{html}{\out{</div>}}

Returns a function like \code{function(x = 0L) { x + x }} and which still calls
\code{chk::chk_integer(x)} prior to executing its body.
}
\details{
\code{typed()} works by inserting code into the body of a function. This is in
contrast to \code{\link[=type_alias]{type_alias()}} and \code{\link[=assign_typed]{assign_typed()}}, both of which create wrappers
around type-checking functions. Consider the following example:

\if{html}{\out{<div class="sourceCode r">}}\preformatted{integer_doubler <- typed(function(x = chk_integer()) \{
 x + x
\})
}\if{html}{\out{</div>}}

This is roughly equivalent to the following:

\if{html}{\out{<div class="sourceCode r">}}\preformatted{integer_doubler <- function(x) \{
 chk_integer(x)
 x + x
\}
}\if{html}{\out{</div>}}

In both cases, what \code{integer_doubler()} does will change if the function
\code{chk_integer()} is overwritten in the environment of \code{integer_doubler()}. In
the worst case scenario, this breaks our contract that the argument \code{x} is
going to be an integer. To prevent such changes, type-checking calls should
be namespaced:

\if{html}{\out{<div class="sourceCode r">}}\preformatted{integer_doubler_stable <- typed(function(x = chk::chk_integer()) \{
 x + x
\})
}\if{html}{\out{</div>}}
}
\examples{
\dontshow{if (requireNamespace("chk", quietly = TRUE)) (if (getRversion() >= "3.4") withAutoprint else force)(\{ # examplesIf}
# Declare the types of arguments
add <- typed(function(x = chk::chk_numeric(), y = chk::chk_numeric()) {
  x + y
})
add(5, 6)
try(add("A", 10))

# Printing the function shows the types of it's arguments
print(add)

# Typed arguments can be declared using type aliases
a_num <- type_alias(chk::chk_numeric(), desc = "A numeric vector.")
add2 <- typed(function(x = a_num, y = a_num) {
  x + y
})
add2(10.5, 0.1)
try(add2(5, TRUE))

# Arguments use the alias's description if available
print(add2)

# Dots can be typed as well
sum2 <- typed(function(... = a_num, na.rm = chk::chk_flag(FALSE)) {
  sum(..., na.rm = na.rm)
})
sum2(1, 2, 3, 4)
try(sum2(1, 2, "C"))
try(sum2(1, 2, 3, na.rm = "no"))
\dontshow{\}) # examplesIf}
}
\seealso{
\code{\link[=as_typed_function]{as_typed_function()}}, \code{\link[=is_typed_function]{is_typed_function()}}, \code{\link[=untype_function]{untype_function()}},
\code{\link[=has_typed_args]{has_typed_args()}}
}
